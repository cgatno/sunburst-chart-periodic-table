(function b(c,d,g){function h(m,p){if(!d[m]){if(!c[m]){var q="function"==typeof require&&require;if(!p&&q)return q(m,!0);if(j)return j(m,!0);var v=new Error("Cannot find module '"+m+"'");throw v.code="MODULE_NOT_FOUND",v}var w=d[m]={exports:{}};c[m][0].call(w.exports,function(x){var y=c[m][1][x];return h(y?y:x)},w,w.exports,b,c,d,g)}return d[m].exports}var j="function"==typeof require&&require;for(var k=0;k<g.length;k++)h(g[k]);return h})({1:[function(b){"use strict";var c=b("./lib/data/DAL/DataSourceAdapter");c.getChartDataSource(function(d){console.log(d)})},{"./lib/data/DAL/DataSourceAdapter":2}],2:[function(b,c){"use strict";/**
 * DataSourceAdapter.js
 * 
 * This is an adapter that generates an array of Group objects which ultimately contain all of the Element objects
 * we'll need to hook up the data source for our Sunburst chart. Generally, the data is returned in the following
 * format:
 * 
 * [(Group->subGroups->elements) ..]
 * 
 */// Pull in dependencies
function d(z){return z.subGroupName===this.type}var g=b("../model/Element"),h=b("../model/SubGroup"),j=b("../model/Group"),k=b("../../util/JsonDataLoader"),m=function(){};// Define constants that we need to properly group elements
const p="Alkali Metal|Alkaline Earth Metal|Metal|Transition Metal|Lanthanide|Actinide".split("|"),q="Nonmetal|Noble Gas|Halogen".split("|"),v="Metalloid|Transactinide".split("|"),w="Shiny, Soft, Highly Reactive, Low Melting Point|Ductile, Malleable, Low Density, High Melting Point|High Melting Point, High Density|Soluble, Highly Reactive|Radioactive, Paramagnetic|Brittle, Poor Metals, Low Melting Point".split("|"),x="Toxic, Highly Reactive, Poor Conductors|Colorless, Odorless, Low Chemical Reactivity|Volatile, Low Elasticity, Good Insulators".split("|"),y="Metallic looking solids, SemiConductors|Radioactive, Synthetic Elements".split("|");// These are all ordered by the type lists above
// The metal and nonmetal descriptions have one extra item for the "Others" category
m.prototype.getChartDataSource=function(z){let A=[],B=new j("Metals");// declare an empty array to add the finished groups to - this is what we will ultimately send as a payload
// Add all of the metals subGroups
for(let E=0;E<p.length;E++)B.subGroups.push(new h(p[E])),B.subGroups[E].characteristics=w[E];B.subGroups.push(new h("Others")),B.subGroups[B.subGroups.length-1].characteristics=w[w.length-1];let C=new j("Non Metals");// Add all of the nonmetal subGroups
for(let E=0;E<q.length;E++)C.subGroups.push(new h(q[E])),C.subGroups[E].characteristics=x[E];C.subGroups.push(new h("Others")),C.subGroups[C.subGroups.length-1].characteristics=x[x.length-1];let D=new j("Others");// Add all of the other subGroups
for(let E=0;E<v.length;E++)D.subGroups.push(new h(v[E])),D.subGroups[E].characteristics=y[E];// Retrieve an array listing of all elements
// TODO: Build in true async functionality so that we can pause execution
// until the JSON is loaded and parsed
k.getObjectFromJson("../../../assets/data/periodic_table_clean.json",function(E){let F=E["periodic-table-elements"];// Loop through all of the elements from the JSON and turn them into Element objects
// then sort them into their groups based on type
for(let G=0;G<F.length;G++){// Make a new Element object for us to work with
let H=new g(F[G]),I,J;// Declare empty currentGroup and currentSubGroup variables then set them based on
// the element type
-1===p.indexOf(H.type)?-1===q.indexOf(H.type)?I=D:(I=C,"Nonmetal"===H.type&&(J=C.subGroups[C.subGroups.length-1])):(I=B,"Metal"===H.type&&(J=B.subGroups[B.subGroups.length-1])),"undefined"==typeof J&&(J=I.subGroups.find(d,H)),J.elements.push(H)}A.push(B),A.push(C),A.push(D),z(A)})},c.exports=new m},{"../../util/JsonDataLoader":6,"../model/Element":3,"../model/Group":4,"../model/SubGroup":5}],3:[function(b,c){"use strict";/**
 * Element.js
 * 
 * A module for representing individual elements and exposing their properties
 * 
 *//**
 * Instantiates a new Element object from the object obtained by parsing assets/data/periodic_table_clean.json
 * with our in-house JsonDataLoader
 * 
 * @param {Object} elementJObj - the object obtained by parsing assets/data/periodic_table_clean.json
 * with our in-house JsonDataLoader
 */c.exports=function(d){this.atomicNumber=d.properties["atomic-number"],this.atomicWeight=d.properties["atomic-weight"],this.elementName=d.properties.element,this.eleSymbol=d.properties.symbol,this.type=d.properties.type,this.value=1}},{}],4:[function(b,c){"use strict";/**
 * Group.js
 * 
 * A module for representing the major groups that categorize elements
 * 
 *//**
 * Instantiate a new Group object with the given groupName and an empty subGroups array.
 * 
 * @param {string} groupName
 */c.exports=function(d){this.groupName=d,this.subGroups=[]}},{}],5:[function(b,c){"use strict";/**
 * SubGroup.js
 * 
 * A module for representing the subgroups that further specify element categories and properties
 * 
 *//**
 * Instantiate a new SubGroup object with the given subGroupname and some empty properties.
 * 
 * @param {string} subGroupName
 */c.exports=function(d){this.subGroupName=d,this.elements=[],this.characteristics=""}},{}],6:[function(b,c){"use strict";/**
 * JsonDataLoader.js
 * 
 * Exposes a module, JsonDataLoader, that provides utility methods for loading JSON from a file
 * (either on the local file system or from a remote source) into a JavaScript object.
 * 
 * Note that I'm writing all of the core components of this project myself so that it can be used for
 * educational purposes. If you're looking for a more packaged and possibly more efficient solution to this specific
 * task, I recommend that you check out:
 * 
 *  - https://www.npmjs.com/package/json-loader
 * 
 *//* Define JSDoc callback types *//**
 * This is a readFileCallback for returning file contents as a string.
 *
 * @callback readFileCallback
 * @param {string} fileContents - the file contents read from the specified file
 *//**
 * This is a loadObjectCallback for returning an object parsed out from JSON
 *
 * @callback loadObjectCallback
 * @param {Object} jsonObject - the JavaScript object parsed from the specified JSON file
 *//**
 * This is a privately scoped function to read a local or remote file's text contents and return them as a payload to a 
 * callback function.
 * 
 * @param {string} filePath - a relative or absolute local path or a remote URL to the file to read
 * @param {readFileCallback} callback - a callback function that is passed the file contents as a string upon success
 */function d(h,j){let k=new XMLHttpRequest;k.onload=j,k.open("get",h,!0),k.send()}/**
 * Loads a JSON file and parses its contents into a new JavaScript object
 * 
 * @param {string} jsonFilePath - a relative or absolute local path or a remote URL to the file to read 
 * @param {loadObjectCallback} callback - a function that is passed the parsed JSON as a JavaScript object upon loading
 */var g=function(){};g.prototype.getObjectFromJson=function(h,j){d(h,function(){j(JSON.parse(this.responseText))})},c.exports=new g},{}]},{},[1]);
