(function b(c,d,g){function h(m,p){if(!d[m]){if(!c[m]){var q="function"==typeof require&&require;if(!p&&q)return q(m,!0);if(j)return j(m,!0);var v=new Error("Cannot find module '"+m+"'");throw v.code="MODULE_NOT_FOUND",v}var w=d[m]={exports:{}};c[m][0].call(w.exports,function(x){var y=c[m][1][x];return h(y?y:x)},w,w.exports,b,c,d,g)}return d[m].exports}var j="function"==typeof require&&require;for(var k=0;k<g.length;k++)h(g[k]);return h})({1:[function(b){"use strict";var c=b("./lib/data/DAL/DataSourceAdapter"),d=b("./lib/view/ViewAdapter");// Declare the sunburst object in the global scope so we can reference it in
// event handlers, etc.
c.getChartDataSource(function(g){let h=new wijmo.chart.hierarchical.Sunburst("#periodic-sunburst");// Let the Sunburst Chart know we're going to start making changes
h.beginUpdate(),h.legend.position="None",h.innerRadius=0.3,h.selectionMode="Point",h.dataLabel.position="Center",h.dataLabel.content="{name}",h.itemsSource=g,h.binding="value",h.bindingName=["groupName","subGroupName","eleSymbol"],h.childItemsPath=["subGroups","elements"],h.hostElement.addEventListener("click",function(j){let k=h.hitTest(j.pageX,j.pageY);console.log(d.mapChartNameToObject(k.name,h.collectionView))}),h.endUpdate(),console.log("Sunburst chart initialized:"),console.log(h)})},{"./lib/data/DAL/DataSourceAdapter":2,"./lib/view/ViewAdapter":7}],2:[function(b,c){"use strict";/**
 * DataSourceAdapter.js
 * 
 * This is an adapter that generates an array of Group objects which ultimately contain all of the Element objects
 * we'll need to hook up the data source for our Sunburst chart. Generally, the data is returned in the following
 * format:
 * 
 * [(Group->subGroups->elements) ..]
 * 
 */// Pull in dependencies
function d(z){return z.subGroupName===this.type}var g=b("../model/Element"),h=b("../model/SubGroup"),j=b("../model/Group"),k=b("../../util/JsonDataLoader"),m=function(){};// Define constants that we need to properly group elements
const p="Alkali Metal|Alkaline Earth Metal|Transition Metal|Lanthanide|Actinide|Metal".split("|"),q="Noble Gas|Halogen|Nonmetal".split("|"),v="Metalloid|Transactinide".split("|"),w="Shiny, Soft, Highly Reactive, Low Melting Point|Ductile, Malleable, Low Density, High Melting Point|High Melting Point, High Density|Soluble, Highly Reactive|Radioactive, Paramagnetic|Brittle, Poor Metals, Low Melting Point".split("|"),x="Toxic, Highly Reactive, Poor Conductors|Colorless, Odorless, Low Chemical Reactivity|Volatile, Low Elasticity, Good Insulators".split("|"),y="Metallic looking solids, SemiConductors|Radioactive, Synthetic Elements".split("|");// These are all ordered by the type lists above
// The metal and nonmetal descriptions have one extra item for the "Others" category
m.prototype.getChartDataSource=function(z){let A=[],B=new j("Metals");// declare an empty array to add the finished groups to - this is what we will ultimately send as a payload
// Add all of the metals subGroups
for(let E=0;E<p.length;E++)"Metal"===p[E]?B.subGroups.push(new h("Other Metals")):B.subGroups.push(new h(p[E])),B.subGroups[E].characteristics=w[E];let C=new j("Nonmetals");// Add all of the nonmetal subGroups
for(let E=0;E<q.length;E++)"Nonmetal"===q[E]?C.subGroups.push(new h("Other Nonmetals")):C.subGroups.push(new h(q[E])),C.subGroups[E].characteristics=x[E];let D=new j("Others");// Add all of the other subGroups
for(let E=0;E<v.length;E++)D.subGroups.push(new h(v[E])),D.subGroups[E].characteristics=y[E];// Retrieve an array listing of all elements
// TODO: Build in true async functionality so that we can pause execution
// until the JSON is loaded and parsed
k.getObjectFromJson("../../../assets/data/periodic_table_clean.json",function(E){let F=E["periodic-table-elements"];// Loop through all of the elements from the JSON and turn them into Element objects
// then sort them into their groups based on type
for(let G=0;G<F.length;G++){// Make a new Element object for us to work with
let H=new g(F[G]),I,J;// Declare empty currentGroup and currentSubGroup variables then set them based on
// the element type
-1===p.indexOf(H.type)?-1===q.indexOf(H.type)?I=D:(I=C,"Nonmetal"===H.type&&(J=C.subGroups[C.subGroups.length-1])):(I=B,"Metal"===H.type&&(J=B.subGroups[B.subGroups.length-1])),"undefined"==typeof J&&(J=I.subGroups.find(d,H)),J.elements.push(H)}A.push(B),A.push(C),A.push(D),z(A)})},c.exports=new m},{"../../util/JsonDataLoader":6,"../model/Element":3,"../model/Group":4,"../model/SubGroup":5}],3:[function(b,c){"use strict";/**
 * Element.js
 * 
 * A module for representing individual elements and exposing their properties
 * 
 *//**
 * Instantiates a new Element object from the object obtained by parsing assets/data/periodic_table_clean.json
 * with our in-house JsonDataLoader
 * 
 * @param {Object} elementJObj - the object obtained by parsing assets/data/periodic_table_clean.json
 * with our in-house JsonDataLoader
 */c.exports=function(d){this.atomicNumber=d.properties["atomic-number"],this.atomicWeight=d.properties["atomic-weight"],this.elementName=d.properties.element,this.eleSymbol=d.properties.symbol,this.type=d.properties.type,this.value=1}},{}],4:[function(b,c){"use strict";/**
 * Group.js
 * 
 * A module for representing the major groups that categorize elements
 * 
 *//**
 * Instantiate a new Group object with the given groupName and an empty subGroups array.
 * 
 * @param {string} groupName
 */c.exports=function(d){this.groupName=d,this.subGroups=[]}},{}],5:[function(b,c){"use strict";/**
 * SubGroup.js
 * 
 * A module for representing the subgroups that further specify element categories and properties
 * 
 *//**
 * Instantiate a new SubGroup object with the given subGroupname and some empty properties.
 * 
 * @param {string} subGroupName
 */c.exports=function(d){this.subGroupName=d,this.elements=[],this.characteristics=""}},{}],6:[function(b,c){"use strict";/**
 * JsonDataLoader.js
 * 
 * Exposes a module, JsonDataLoader, that provides utility methods for loading JSON from a file
 * (either on the local file system or from a remote source) into a JavaScript object.
 * 
 * Note that I'm writing all of the core components of this project myself so that it can be used for
 * educational purposes. If you're looking for a more packaged and possibly more efficient solution to this specific
 * task, I recommend that you check out:
 * 
 *  - https://www.npmjs.com/package/json-loader
 * 
 *//* Define JSDoc callback types *//**
 * This is a readFileCallback for returning file contents as a string.
 *
 * @callback readFileCallback
 * @param {string} fileContents - the file contents read from the specified file
 *//**
 * This is a loadObjectCallback for returning an object parsed out from JSON
 *
 * @callback loadObjectCallback
 * @param {Object} jsonObject - the JavaScript object parsed from the specified JSON file
 *//**
 * This is a privately scoped function to read a local or remote file's text contents and return them as a payload to a 
 * callback function.
 * 
 * @param {string} filePath - a relative or absolute local path or a remote URL to the file to read
 * @param {readFileCallback} callback - a callback function that is passed the file contents as a string upon success
 */function d(h,j){let k=new XMLHttpRequest;k.onload=j,k.open("get",h,!0),k.send()}/**
 * Loads a JSON file and parses its contents into a new JavaScript object
 * 
 * @param {string} jsonFilePath - a relative or absolute local path or a remote URL to the file to read 
 * @param {loadObjectCallback} callback - a function that is passed the parsed JSON as a JavaScript object upon loading
 */var g=function(){};g.prototype.getObjectFromJson=function(h,j){d(h,function(){j(JSON.parse(this.responseText))})},c.exports=new g},{}],7:[function(b,c){"use strict";/**
 * ViewAdapter.js
 * 
 * Provides some helper methods for handling Sunburst Chart events and generating the "property tiles"
 * dynamically based on chart selections.
 * 
 */// Pull in dependencies
function d(k,m){// We should be entering this method with the haystack being an array of Groups, SubGroups, or Elements
// We have to loop through the array and, depending on the type of object, check to see if it's what
// we're looking for
for(let p=0;p<k.length;p++){let q=k[p];if(q instanceof h){// we have a Group
if(q.groupName===m)return q;let v=d(q.subGroups,m);if("undefined"!=typeof v)return v}else if(q instanceof g){// we have a SubGroup
if(q.subGroupName===m)return q;let v=d(q.elements,m);if("undefined"!=typeof v)return v}else// must be an Element
if(q.eleSymbol===m)return q}}b("../data/model/Element");var g=b("../data/model/SubGroup"),h=b("../data/model/Group"),j=function(){};j.prototype.mapChartNameToObject=function(k,m){let p=m.items;// grab the array of Group objects from the chart
return d(p,k)},c.exports=new j},{"../data/model/Element":3,"../data/model/Group":4,"../data/model/SubGroup":5}]},{},[1]);
