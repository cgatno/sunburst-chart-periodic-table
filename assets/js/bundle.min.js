(function b(c,d,g){function h(m,p){if(!d[m]){if(!c[m]){var q="function"==typeof require&&require;if(!p&&q)return q(m,!0);if(j)return j(m,!0);var v=new Error("Cannot find module '"+m+"'");throw v.code="MODULE_NOT_FOUND",v}var w=d[m]={exports:{}};c[m][0].call(w.exports,function(x){var y=c[m][1][x];return h(y?y:x)},w,w.exports,b,c,d,g)}return d[m].exports}var j="function"==typeof require&&require;for(var k=0;k<g.length;k++)h(g[k]);return h})({1:[function(b){"use strict";var c=b("./lib/data/DAL/DataSourceAdapter"),d=b("./lib/view/ViewAdapter"),g=b("./lib/view/PropertiesTile");// Declare the sunburst object in the global scope so we can reference it in
// event handlers, etc.
c.getChartDataSource(function(h){/**
     * Visually marks a panel at the given coordinates as selected
     * 
     * @param {number} panelX the X coordinate of the panel to mark
     * @param {number} panelY the Y coordinate of the panel to mark
     */function j(x,y){"undefined"!=typeof p&&"undefined"!=typeof q&&p.setAttribute("fill",q);// Define our selected element and check to see if it's a panel that we can fill
let z=document.elementFromPoint(x,y);if("undefined"!=typeof z&&z.hasAttribute("fill")&&"path"===z.tagName){v&&(w.style.display="",v=!1),p=z;let A=z.getAttribute("fill");q=A;let B=A.replace("rgba(","").replace(")","").split(",");B[3]="1.0",z.setAttribute("fill","rgba("+B.join(",")+")")}else"undefined"!=typeof z&&"text"===z.tagName&&(z.style.display="none",w=z,v=!0,j(x,y))}// Let the chart know that everything is updated now
// Initialize the property tile by loading it into its module
let k=new g(document.getElementById("properties-tile"));// Here we hook up PropertyTile's centerInParent() method to the window's resize event
window.onresize=function(){k.centerInParent()};let m=new wijmo.chart.hierarchical.Sunburst("#periodic-sunburst");// initialize!
// Let the Sunburst Chart know we're going to start making changes
m.beginUpdate(),m.legend.position="None",m.innerRadius=0.3,m.selectionMode="Point",m.dataLabel.position="Center",m.dataLabel.content="{name}",m.itemsSource=h,m.binding="value",m.bindingName=["groupName","subGroupName","eleSymbol"],m.childItemsPath=["subGroups","elements"],m.hostElement.addEventListener("click",function(x){j(x.pageX,x.pageY);// Perform a hit test to get a clicked panel's name then use it to set up the info panel via the ViewAdapter
let y=m.hitTest(x.pageX,x.pageY);k.showInfoPanel(d.getObjectFromChartName(y.name,m.collectionView))});// Set selected element variables in this outer scope to preserve them
let p,q,v=!1,w;// Determine if we need to reshow any text elements that we hid to find the right panel
m.endUpdate()})},{"./lib/data/DAL/DataSourceAdapter":2,"./lib/view/PropertiesTile":7,"./lib/view/ViewAdapter":8}],2:[function(b,c){"use strict";/**
 * DataSourceAdapter.js
 * 
 * This is an adapter that generates an array of Group objects which ultimately contain all of the Element objects
 * we'll need to hook up the data source for our Sunburst chart. Generally, the data is returned in the following
 * format:
 * 
 * [(Group->subGroups->elements) ..]
 * 
 *//* Define JSDoc callback types *//**
 * Called when the chart data source is finished loading
 *
 * @callback dataSourceLoadedCallback
 * @param {array} dataArray an array of Group objects containing SubGroups which contain Elements that can be directly loaded into the Sunburst chart
 */// Pull in dependencies
/**
 * A function designed to be used with the array.find() method to search for a SubGroup that matches a given element
 * 
 * @param {Object} subGroup the SubGroup object to compare an element's type to
 * @returns {boolean} true for a match and false for no match
 */function d(z){return z.subGroupName===this.type+("s"===this.type.slice(-1)?"es":"s")}var g=b("../model/Element"),h=b("../model/SubGroup"),j=b("../model/Group"),k=b("../../util/JsonDataLoader"),m=function(){};// Define constants that we need to properly group elements
const p="Alkali Metal|Alkaline Earth Metal|Transition Metal|Lanthanide|Actinide|Metal".split("|"),q="Noble Gas|Halogen|Nonmetal".split("|"),v="Metalloid|Transactinide".split("|"),w="Shiny,Soft,Highly Reactive,Low Melting Point|Ductile,Malleable,Low Density,High Melting Point|High Melting Point,High Density|Soluble,Highly Reactive|Radioactive,Paramagnetic|Brittle,Poor Metals,Low Melting Point".split("|"),x="Toxic,Highly Reactive,Poor Conductors|Colorless,Odorless,Low Chemical Reactivity|Volatile,Low Elasticity,Good Insulators".split("|"),y="Metallic looking solids,Semiconductors|Radioactive,Synthetic Elements".split("|");// These are all ordered by the type lists above
// The metal and nonmetal descriptions have one extra item for the "Others" category
/**
 * Loads the data to display in the Sunburst chart and formats it for delivery
 * 
 * @param {dataSourceLoadedCallback} callback
 */m.prototype.getChartDataSource=function(z){let A=[],B=new j("Metals");// declare an empty array to add the finished groups to - this is what we will ultimately send as a payload
// Add all of the metals subGroups
for(let E=0;E<p.length;E++)"Metal"===p[E]?B.subGroups.push(new h("Other Metals")):B.subGroups.push(new h(p[E]+("s"===p[E].slice(-1)?"es":"s"))),B.subGroups[E].characteristics=w[E];let C=new j("Nonmetals");// Add all of the nonmetal subGroups
for(let E=0;E<q.length;E++)"Nonmetal"===q[E]?C.subGroups.push(new h("Other Nonmetals")):C.subGroups.push(new h(q[E]+("s"===q[E].slice(-1)?"es":"s"))),C.subGroups[E].characteristics=x[E];let D=new j("Others");// Add all of the other subGroups
for(let E=0;E<v.length;E++)D.subGroups.push(new h(v[E]+("s"===v[E].slice(-1)?"es":"s"))),D.subGroups[E].characteristics=y[E];// Retrieve an array listing of all elements
// TODO: Build in true async functionality so that we can pause execution
// until the JSON is loaded and parsed
k.getObjectFromJson("../../../assets/data/periodic_table_clean.json",function(E){let F=E["periodic-table-elements"];// Loop through all of the elements from the JSON and turn them into Element objects
// then sort them into their groups based on type
for(let G=0;G<F.length;G++){// Make a new Element object for us to work with
let H=new g(F[G]),I,J;// Declare empty currentGroup and currentSubGroup variables then set them based on
// the element type
-1===p.indexOf(H.type)?-1===q.indexOf(H.type)?I=D:(I=C,"Nonmetal"===H.type&&(J=C.subGroups[C.subGroups.length-1])):(I=B,"Metal"===H.type&&(J=B.subGroups[B.subGroups.length-1])),"undefined"==typeof J&&(J=I.subGroups.find(d,H)),J.elements.push(H)}// Add our constructed groups to the master collection
A.push(B),A.push(C),A.push(D),z(A)})},c.exports=new m},{"../../util/JsonDataLoader":6,"../model/Element":3,"../model/Group":4,"../model/SubGroup":5}],3:[function(b,c){"use strict";/**
 * Element.js
 * 
 * A module for representing individual elements and exposing their properties
 * 
 *//**
 * Instantiates a new Element object from the object obtained by parsing assets/data/periodic_table_clean.json
 * with our in-house JsonDataLoader
 * 
 * @param {Object} elementJObj the object obtained by parsing assets/data/periodic_table_clean.json
 * with our in-house JsonDataLoader
 */c.exports=function(d){this.atomicNumber=d.properties["atomic-number"],this.atomicWeight=d.properties["atomic-weight"],this.elementName=d.properties.element,this.eleSymbol=d.properties.symbol,this.type=d.properties.type,this.value=1}},{}],4:[function(b,c){"use strict";/**
 * Group.js
 * 
 * A module for representing the major groups that categorize elements
 * 
 *//**
 * Instantiate a new Group object with the given groupName and an empty subGroups array.
 * 
 * @param {string} groupName
 */c.exports=function(d){this.groupName=d,this.subGroups=[]}},{}],5:[function(b,c){"use strict";/**
 * SubGroup.js
 * 
 * A module for representing the subgroups that further specify element categories and properties
 * 
 *//**
 * Instantiate a new SubGroup object with the given subGroupname and some empty properties.
 * 
 * @param {string} subGroupName
 */c.exports=function(d){this.subGroupName=d,this.elements=[],this.characteristics=""}},{}],6:[function(b,c){"use strict";/**
 * JsonDataLoader.js
 * 
 * Exposes a module, JsonDataLoader, that provides utility methods for loading JSON from a file
 * (either on the local file system or from a remote source) into a JavaScript object.
 * 
 * Note that I'm writing all of the core components of this project myself so that it can be used for
 * educational purposes. If you're looking for a more packaged and possibly more efficient solution to this specific
 * task, I recommend that you check out:
 * 
 *  - https://www.npmjs.com/package/json-loader
 * 
 *//* Define JSDoc callback types *//**
 * This is a readFileCallback for returning file contents as a string.
 *
 * @callback readFileCallback
 * @param {string} fileContents the file contents read from the specified file
 *//**
 * This is a loadObjectCallback for returning an object parsed out from JSON
 *
 * @callback loadObjectCallback
 * @param {Object} jsonObject the JavaScript object parsed from the specified JSON file
 *//**
 * This is a privately scoped function to read a local or remote file's text contents and return them as a payload to a 
 * callback function.
 * 
 * @param {string} filePath a relative or absolute local path or a remote URL to the file to read
 * @param {readFileCallback} callback a callback function that is passed the file contents as a string upon success
 */function d(h,j){let k=new XMLHttpRequest;k.onload=j,k.open("get",h,!0),k.send()}/**
 * Loads a JSON file and parses its contents into a new JavaScript object
 * 
 * @param {string} jsonFilePath a relative or absolute local path or a remote URL to the file to read 
 * @param {loadObjectCallback} callback a function that is passed the parsed JSON as a JavaScript object upon loading
 */var g=function(){};g.prototype.getObjectFromJson=function(h,j){d(h,function(){j(JSON.parse(this.responseText))})},c.exports=new g},{}],7:[function(b,c){"use strict";/**
 * PropertiesTile.js
 * 
 * Provides some helper methods for handling Sunburst Chart events and generating the "property tiles"
 * dynamically based on chart selections.
 * 
 */// Pull in dependencies
var d=b("../data/model/Element"),g=b("../data/model/SubGroup"),h=b("../data/model/Group"),j=function(m){this.domElement=m,this.centerInParent()};/**
 * Instantiates a PropertiesTile Object to handle the DOM functions, events and layouts of an element that will display the properties
 * 
 * @param {Object} propertiesTileDomElement - the DOM element to initialize as the properties tile
 *//**
 * Centers the properties tile element in its parent container
 */j.prototype.centerInParent=function(){let m=this.domElement,p=m.parentElement;m.style.top=p.offsetHeight/2-m.offsetHeight/2+"px",m.style.left=p.offsetWidth/2-m.offsetWidth/2+"px"},j.prototype.show=function(){let m=this.domElement;m.style.visibility="visible"},j.prototype.hide=function(){let m=this.domElement;m.style.visibility="hidden"};const k="<br>";/**
 * Initializes an info panel for the provided Group, SubGroup or Element object then shows the properties grid and info panel
 * 
 * @param {Object} infoObject a Group, SubGroup or Element object
 */j.prototype.showInfoPanel=function(m){if("undefined"==typeof m)this.hide();else{// the user selected something on the chart, display the appropriate info
let p=document.getElementById("group-info"),q=document.getElementById("element-info"),v=document.getElementById("subGroup-info");// Hide all of the panes initially
if(p.style.display="none",v.style.display="none",q.style.display="none",m instanceof h){// infoObject is a Group
// Save the subGroup-listing element in a variable since we use it a lot
let w=document.getElementById("subGroup-listing");document.getElementById("group-name").innerText=m.groupName,w.innerHTML="";// Show all SubGroups and the number of elements in each
for(let x=0;x<m.subGroups.length;x++)w.innerHTML+=m.subGroups[x].subGroupName,w.innerHTML+=" ",w.innerHTML+="("+m.subGroups[x].elements.length+")",w.innerHTML+=k;p.style.display="block"}else if(m instanceof g){document.getElementById("subGroup-name").innerText=m.subGroupName,document.getElementById("num-elements").innerText=m.elements.length;// Save the characteristic-listing element in a variable since we use it a lot
let w=document.getElementById("characteristic-listing");w.innerHTML="";// Split the characteristics up so we can display them as a list
let x=m.characteristics.split(",");for(let y=0;y<x.length;y++)w.innerHTML+=x[y],w.innerHTML+=k;v.style.display="block"}else m instanceof d&&(document.getElementById("element-symbol").innerText=m.eleSymbol,document.getElementById("element-name").innerText=m.elementName,document.getElementById("atomic-number").innerText=m.atomicNumber,document.getElementById("atomic-weight").innerText=(+m.atomicWeight).toFixed(2),q.style.display="block");// Center properties tile in the parent then show it
this.centerInParent(),this.show()}},c.exports=j},{"../data/model/Element":3,"../data/model/Group":4,"../data/model/SubGroup":5}],8:[function(b,c){"use strict";/**
 * ViewAdapter.js
 * 
 * Provides some helper methods for handling Sunburst Chart events and generating the "property tiles"
 * dynamically based on chart selections.
 * 
 */// Pull in dependencies
/**
 * An internal function that recursively searches through the chart's object collection for an object with a name that matches the search term
 * 
 * @param {Array} haystack an array of Objects to search through. In this case, this should be the root items array from a the Sunburst chart's collectionView
 * @param {string} needle a search term to look for in the object collection. This should be a panel data label/name from the chart
 * @returns {Object} a Group, SubGroup or Element if the lookup succeeds
 */function d(k,m){// We should be entering this method with the haystack being an array of Groups, SubGroups, or Elements
// We have to loop through the array and, depending on the type of object, check to see if it's what
// we're looking for
for(let p=0;p<k.length;p++){let q=k[p];if(q instanceof h){// we have a Group
if(q.groupName===m)return q;let v=d(q.subGroups,m);if("undefined"!=typeof v)return v}else if(q instanceof g){// we have a SubGroup
if(q.subGroupName===m)return q;let v=d(q.elements,m);if("undefined"!=typeof v)return v}else// must be an Element
if(q.eleSymbol===m)return q}}b("../data/model/Element");var g=b("../data/model/SubGroup"),h=b("../data/model/Group"),j=function(){};/**
 * Gets an object associated with a panel on the Sunburst chart by looking up the data label/name for that panel
 * 
 * @param {string} chartItemName the data label/name of a chart panel
 * @param {Object} chartCollectionView the chart's collectionView object
 * @returns {Object} a Group, SubGroup or Element object found by looking up the chartItemName
 */j.prototype.getObjectFromChartName=function(k,m){let p=m.items;// grab the array of Group objects from the chart
return d(p,k)},c.exports=new j},{"../data/model/Element":3,"../data/model/Group":4,"../data/model/SubGroup":5}]},{},[1]);
