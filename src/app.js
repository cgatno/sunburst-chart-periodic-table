// Load module dependencies
const DataSourceAdapter = require('./data/DAL/DataSourceAdapter');
const PropertiesTile = require('./view/PropertiesTile');

/** Handle visual marking of a selected panel on the chart */

// Set selected element variables in this outer scope to preserve them
let lastSelectedEle;
let lastSelectedEleFillColor;

// Determine if we need to reshow any text elements that we hid to find the right panel
let reshowText = false;
let hiddenTextElement;

/**
   * A (potentially) recursive function that visually marks a panel at the given coordinates as
   * selected. If a text label is clicked, the function will temporarily hide the label and recurse
   * to ultimately locate the panel below.
   *
   * @param {number} panelX the X coordinate of the panel to mark
   * @param {number} panelY the Y coordinate of the panel to mark
   */
function markSelectedPanel(panelX, panelY) {
  // First, 'unselect' (restore fill color) the element that was selected last, if there is one
  if (typeof (lastSelectedEle) !== 'undefined' && typeof (lastSelectedEleFillColor) !== 'undefined') {
    lastSelectedEle.setAttribute('fill', lastSelectedEleFillColor);
  }

  // Define our selected element and check to see if it's a panel that we can fill
  const selectedElement = document.elementFromPoint(panelX, panelY);
  if (typeof (selectedElement) !== 'undefined' &&
    selectedElement.hasAttribute('fill') &&
    selectedElement.tagName === 'path') {
    if (reshowText) { // if we hid a text element last time, show it now
      hiddenTextElement.style.display = '';
      reshowText = false;
    }

    // Reset the lastSelectedEle and then change the fill color of the clicked panel
    lastSelectedEle = selectedElement;
    const fillColor = selectedElement.getAttribute('fill');
    lastSelectedEleFillColor = fillColor;
    const rgbaValues = fillColor.replace('rgba(', '').replace(')', '').split(',');
    rgbaValues[3] = '1.0';
    selectedElement.setAttribute('fill', `rgba(${rgbaValues.join(',')})`);
  } else if (typeof (selectedElement) !== 'undefined' && selectedElement.tagName === 'text') { // super hacky way to get the right panel if a data label is clicked
    // Hide the data label
    selectedElement.style.display = 'none';
    // Set our outer scope variables so the text element is reshown
    hiddenTextElement = selectedElement;
    reshowText = true;
    // Run the method again with the data label hidden
    markSelectedPanel(panelX, panelY);
  }
}

/* Chart initialization */

// Declare the sunburst object in the global scope so we can reference it in
// event handlers, etc.
DataSourceAdapter.getChartDataSource((elementCollectionView) => {
  // Initialize the property tile by loading it and attaching it to the chart's DOM element
  const myPropTile = new PropertiesTile();
  myPropTile.attachToDom(document.getElementById('properties-tile'));
  // Here we hook up PropertyTile's centerInParent() method to the window's resize event
  window.onresize = function _handleWindowResize() {
    myPropTile.centerInParent();
  };

  const mySunburst = new wijmo.chart.hierarchical.Sunburst('#periodic-sunburst'); // initialize!

  // Let the Sunburst Chart know we're going to start making changes
  mySunburst.beginUpdate();

  // Set some stylistic properties for the chart
  mySunburst.legend.position = 'None'; // hide the legend
  mySunburst.innerRadius = 0.3; // set up a relatively large space for displaying info
  mySunburst.selectionMode = 'Point';
  mySunburst.dataLabel.position = 'Center'; // center panel labels
  mySunburst.dataLabel.content = '{name}'; // the panel should display its name (derived from bindingName property)

  // set the items source to the array generated by the DataSourceAdapter
  mySunburst.itemsSource = elementCollectionView.groups;
  // bind each item to the constant 'arcLengthValue' property to get equal arc angles for all
  // element panels (see DataSourceAdapter.js, line 53)
  mySunburst.binding = 'arcLengthValue';
  // set the property that gives the name we want to display for each chart level
  mySunburst.bindingName = ['name', 'name', 'symbol'];
  // set the property names that hold the children for each level (remember our data structure is
  // Group.subGroups.elements)
  mySunburst.childItemsPath = ['groups', 'items'];

  // Set up a function to listen for click events on the Sunburst Chart's parent DOM element
  mySunburst.hostElement.addEventListener('click', (e) => {
    // If a panel is clicked, visually select it
    markSelectedPanel(e.clientX, e.clientY);

    // Perform a hit test to get a clicked panel's associate JavaScript object
    const ht = mySunburst.hitTest(e);
    myPropTile.showInfoPanel(ht.item);
  });

  // Let the chart know that everything is updated now
  mySunburst.endUpdate();
});
